# ğŸŒŠ Moonwave êµ¬ë…ê´€ë¦¬ ERD v2.0 (2025 ìµœì‹ /ìƒì„¸)

## 1. ì „ì²´ ERD êµ¬ì¡° ê°œìš”

```mermaid
erDiagram
    auth_users ||--o{ subscriptions : "1:N"
    auth_users ||--|| exchange_rates : "1:1"
    auth_users ||--o{ subscription_alarms : "1:N"
    auth_users ||--o{ notification_history : "1:N"
    auth_users ||--o{ user_categories : "1:N"
    auth_users ||--o{ payment_methods : "1:N"
    
    subscriptions ||--o{ subscription_alarms : "1:N"
    subscriptions ||--o{ subscription_history : "1:N"
    subscriptions ||--o{ subscription_categories : "1:N"
    
    user_categories ||--o{ subscription_categories : "1:N"
    payment_methods ||--o{ subscriptions : "1:N"
```

### ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ì›ì¹™
- **ìœ ì € ê²©ë¦¬**: ëª¨ë“  ë°ì´í„°ëŠ” user_idë¡œ ì™„ì „ ë¶„ë¦¬
- **Soft Delete**: ì¤‘ìš” ë°ì´í„°ëŠ” ì‚­ì œ ëŒ€ì‹  ìƒíƒœ ë³€ê²½
- **ê°ì‚¬ ì¶”ì **: created_at, updated_at í•„ìˆ˜
- **íƒ€ì… ì•ˆì „ì„±**: ENUM ëŒ€ì‹  CHECK ì œì•½ ì‚¬ìš©
- **ì„±ëŠ¥ ìµœì í™”**: ì ì ˆí•œ ì¸ë±ìŠ¤ì™€ íŒŒí‹°ì…”ë‹

---

## 2. í…Œì´ë¸” ìƒì„¸ ì •ì˜

### 2.1 auth.users (Supabase Auth ì œê³µ)
```sql
-- Supabase Authì—ì„œ ê´€ë¦¬í•˜ëŠ” ì‚¬ìš©ì í…Œì´ë¸”
-- id (UUID): ëª¨ë“  í…Œì´ë¸”ì˜ user_id FKë¡œ ì‚¬ìš©
-- email, created_at, updated_at ë“± ê¸°ë³¸ í•„ë“œ í¬í•¨
```

### 2.2 subscriptions (êµ¬ë… ì„œë¹„ìŠ¤)
```sql
CREATE TABLE subscriptions (
    -- ê¸°ë³¸ ì‹ë³„ì
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- ì„œë¹„ìŠ¤ ì •ë³´
    service_name TEXT NOT NULL,
    service_url TEXT,
    service_image_url TEXT, -- ì„œë¹„ìŠ¤ ë¡œê³  URL ë˜ëŠ” Storage ê²½ë¡œ
    service_id TEXT, -- ì™¸ë¶€ ì„œë¹„ìŠ¤ ê³ ìœ  ID (ì„ íƒ)
    
    -- ê²°ì œ ì •ë³´
    amount NUMERIC(12,2) NOT NULL CHECK (amount >= 0),
    currency TEXT NOT NULL CHECK (currency IN ('KRW', 'USD')),
    payment_cycle TEXT NOT NULL CHECK (payment_cycle IN ('monthly', 'yearly', 'once')),
    payment_day INTEGER CHECK (payment_day >= 1 AND payment_day <= 31),
    payment_method_id UUID REFERENCES payment_methods(id) ON DELETE SET NULL,
    
    -- êµ¬ë… ìƒíƒœ
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'paused', 'canceled')),
    start_date DATE NOT NULL DEFAULT CURRENT_DATE,
    end_date DATE,
    next_payment_date DATE, -- ìë™ ê³„ì‚° í•„ë“œ
    auto_renewal BOOLEAN DEFAULT true,
    
    -- ë¶„ë¥˜ ë° íƒœê·¸
    tier TEXT, -- Basic, Premium, Enterprise ë“±
    benefits TEXT, -- ì£¼ìš” í˜œíƒ ì„¤ëª…
    tags TEXT[] DEFAULT '{}', -- ì‚¬ìš©ì ì •ì˜ íƒœê·¸
    memo TEXT, -- ì‚¬ìš©ì ë©”ëª¨
    
    -- ì•Œë¦¼ ì„¤ì • (ê¸°ë³¸ê°’)
    alarm_days INTEGER[] DEFAULT '{3,1,0}', -- 3ì¼ì „, 1ì¼ì „, ë‹¹ì¼
    
    -- ë©”íƒ€ë°ì´í„°
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ, -- Soft delete
    
    -- ì¸ë±ìŠ¤ë¥¼ ìœ„í•œ ê³„ì‚° í•„ë“œ
    is_active BOOLEAN GENERATED ALWAYS AS (status = 'active' AND deleted_at IS NULL) STORED,
    monthly_amount NUMERIC GENERATED ALWAYS AS (
        CASE 
            WHEN payment_cycle = 'monthly' THEN amount
            WHEN payment_cycle = 'yearly' THEN amount / 12
            ELSE 0
        END
    ) STORED
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_payment_day ON subscriptions(payment_day) WHERE is_active = true;
CREATE INDEX idx_subscriptions_next_payment ON subscriptions(next_payment_date) WHERE is_active = true;
CREATE INDEX idx_subscriptions_status ON subscriptions(status) WHERE deleted_at IS NULL;
```

### 2.3 exchange_rates (í™˜ìœ¨ ì •ë³´)
```sql
CREATE TABLE exchange_rates (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    usd_krw NUMERIC(10,4) NOT NULL DEFAULT 1300.0000 CHECK (usd_krw > 0),
    auto_update BOOLEAN DEFAULT false, -- ìë™ ì—…ë°ì´íŠ¸ ì—¬ë¶€
    last_auto_update TIMESTAMPTZ, -- ë§ˆì§€ë§‰ ìë™ ì—…ë°ì´íŠ¸ ì‹œê°
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 2.4 subscription_alarms (ì•ŒëŒ ì„¤ì •)
```sql
CREATE TABLE subscription_alarms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
    
    -- ì•ŒëŒ ìœ í˜• ë° ì„¤ì •
    alarm_type TEXT NOT NULL CHECK (alarm_type IN (
        'payment_due', -- ê²°ì œ ì˜ˆì •
        'payment_failed', -- ê²°ì œ ì‹¤íŒ¨
        'price_changed', -- ê°€ê²© ë³€ë™
        'subscription_expiring', -- êµ¬ë… ë§Œë£Œ ì„ë°•
        'auto_renewal', -- ìë™ ê°±ì‹ 
        'benefit_expiring' -- í˜œíƒ ë§Œë£Œ
    )),
    alarm_day INTEGER NOT NULL, -- Nì¼ ì „ (ìŒìˆ˜ëŠ” Nì¼ í›„)
    alarm_time TIME DEFAULT '09:00:00', -- ì•ŒëŒ ì‹œê°
    
    -- ìƒíƒœ
    is_active BOOLEAN DEFAULT true,
    last_triggered_at TIMESTAMPTZ,
    
    -- ë©”íƒ€ë°ì´í„°
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- ë³µí•© ìœ ë‹ˆí¬ ì œì•½
    UNIQUE(subscription_id, alarm_type, alarm_day)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_alarms_active ON subscription_alarms(subscription_id, is_active) WHERE is_active = true;
CREATE INDEX idx_alarms_trigger ON subscription_alarms(alarm_day, alarm_time) WHERE is_active = true;
```

### 2.5 user_categories (ì‚¬ìš©ì ì •ì˜ ì¹´í…Œê³ ë¦¬)
```sql
CREATE TABLE user_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    color TEXT DEFAULT '#3B82F6', -- HEX ìƒ‰ìƒ ì½”ë“œ
    icon TEXT, -- ì•„ì´ì½˜ ì´ë¦„ ë˜ëŠ” ì´ëª¨ì§€
    sort_order INTEGER DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(user_id, name)
);

-- ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ ì‚½ì… íŠ¸ë¦¬ê±°
CREATE OR REPLACE FUNCTION create_default_categories()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO user_categories (user_id, name, color, sort_order) VALUES
    (NEW.id, 'ì—”í„°í…Œì¸ë¨¼íŠ¸', '#EF4444', 1),
    (NEW.id, 'ìƒì‚°ì„±', '#3B82F6', 2),
    (NEW.id, 'êµìœ¡', '#10B981', 3),
    (NEW.id, 'ìŒì•…', '#8B5CF6', 4),
    (NEW.id, 'í´ë¼ìš°ë“œ', '#F59E0B', 5),
    (NEW.id, 'ê¸°íƒ€', '#6B7280', 99);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER create_user_categories_trigger
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION create_default_categories();
```

### 2.6 subscription_categories (êµ¬ë…-ì¹´í…Œê³ ë¦¬ ì—°ê²°)
```sql
CREATE TABLE subscription_categories (
    subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
    category_id UUID NOT NULL REFERENCES user_categories(id) ON DELETE CASCADE,
    
    PRIMARY KEY (subscription_id, category_id)
);
```

### 2.7 payment_methods (ê²°ì œ ìˆ˜ë‹¨)
```sql
CREATE TABLE payment_methods (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- ê²°ì œ ìˆ˜ë‹¨ ì •ë³´
    method_type TEXT NOT NULL CHECK (method_type IN ('card', 'bank', 'paypal', 'other')),
    provider TEXT NOT NULL, -- ì¹´ë“œì‚¬, ì€í–‰ëª… ë“±
    last_four TEXT, -- ì¹´ë“œ/ê³„ì¢Œ ë 4ìë¦¬
    nickname TEXT, -- ì‚¬ìš©ì ì •ì˜ ë³„ì¹­
    
    -- ìƒíƒœ
    is_active BOOLEAN DEFAULT true,
    is_default BOOLEAN DEFAULT false,
    
    -- ë©”íƒ€ë°ì´í„°
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(user_id, nickname)
);

-- ê¸°ë³¸ ê²°ì œìˆ˜ë‹¨ì€ ìœ ì €ë‹¹ í•˜ë‚˜ë§Œ
CREATE UNIQUE INDEX idx_default_payment_method ON payment_methods(user_id) WHERE is_default = true;
```

### 2.8 subscription_history (êµ¬ë… ë³€ê²½ ì´ë ¥)
```sql
CREATE TABLE subscription_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
    
    -- ë³€ê²½ ì •ë³´
    change_type TEXT NOT NULL CHECK (change_type IN (
        'created', 'updated', 'paused', 'resumed', 'canceled', 'renewed', 'price_changed'
    )),
    changed_fields JSONB, -- ë³€ê²½ëœ í•„ë“œì™€ ì´ì „/ì´í›„ ê°’
    change_reason TEXT,
    
    -- ìŠ¤ëƒ…ìƒ· (ë³€ê²½ ì‹œì ì˜ ì „ì²´ ë°ì´í„°)
    snapshot JSONB NOT NULL,
    
    -- ë©”íƒ€ë°ì´í„°
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_history_subscription ON subscription_history(subscription_id, created_at DESC);
```

### 2.9 notification_history (ì•Œë¦¼ ë°œì†¡ ì´ë ¥)
```sql
CREATE TABLE notification_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
    alarm_id UUID REFERENCES subscription_alarms(id) ON DELETE SET NULL,
    
    -- ì•Œë¦¼ ì •ë³´
    notification_type TEXT NOT NULL,
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    
    -- ë°œì†¡ ì •ë³´
    channel TEXT NOT NULL CHECK (channel IN ('email', 'push', 'in_app')),
    sent_at TIMESTAMPTZ DEFAULT NOW(),
    read_at TIMESTAMPTZ,
    
    -- ë©”íƒ€ë°ì´í„°
    metadata JSONB DEFAULT '{}'
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_notifications_user ON notification_history(user_id, sent_at DESC);
CREATE INDEX idx_notifications_unread ON notification_history(user_id, read_at) WHERE read_at IS NULL;
```

---

## 3. Row Level Security (RLS) ì •ì±…

```sql
-- ëª¨ë“  í…Œì´ë¸”ì— RLS í™œì„±í™”
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE exchange_rates ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscription_alarms ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_history ENABLE ROW LEVEL SECURITY;

-- subscriptions ì •ì±…
CREATE POLICY "Users can CRUD their own subscriptions" ON subscriptions
    FOR ALL USING (auth.uid() = user_id);

-- exchange_rates ì •ì±…
CREATE POLICY "Users can manage their own exchange rate" ON exchange_rates
    FOR ALL USING (auth.uid() = user_id);

-- subscription_alarms ì •ì±…
CREATE POLICY "Users can manage their own alarms" ON subscription_alarms
    FOR ALL USING (auth.uid() = user_id);

-- user_categories ì •ì±…
CREATE POLICY "Users can manage their own categories" ON user_categories
    FOR ALL USING (auth.uid() = user_id);

-- payment_methods ì •ì±…
CREATE POLICY "Users can manage their own payment methods" ON payment_methods
    FOR ALL USING (auth.uid() = user_id);

-- notification_history ì •ì±…
CREATE POLICY "Users can view their own notifications" ON notification_history
    FOR SELECT USING (auth.uid() = user_id);
```

---

## 4. íŠ¸ë¦¬ê±° ë° í•¨ìˆ˜

### 4.1 ìë™ updated_at ì—…ë°ì´íŠ¸
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ëª¨ë“  í…Œì´ë¸”ì— íŠ¸ë¦¬ê±° ì ìš©
CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    
CREATE TRIGGER update_exchange_rates_updated_at BEFORE UPDATE ON exchange_rates
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    
CREATE TRIGGER update_user_categories_updated_at BEFORE UPDATE ON user_categories
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    
CREATE TRIGGER update_payment_methods_updated_at BEFORE UPDATE ON payment_methods
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### 4.2 ë‹¤ìŒ ê²°ì œì¼ ìë™ ê³„ì‚°
```sql
CREATE OR REPLACE FUNCTION calculate_next_payment_date()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'active' AND NEW.auto_renewal = true THEN
        NEW.next_payment_date = CASE
            WHEN NEW.payment_cycle = 'monthly' THEN 
                (NEW.start_date + INTERVAL '1 month' * 
                CEIL(EXTRACT(EPOCH FROM (NOW() - NEW.start_date)) / (30 * 24 * 60 * 60)))::DATE
            WHEN NEW.payment_cycle = 'yearly' THEN 
                (NEW.start_date + INTERVAL '1 year' * 
                CEIL(EXTRACT(EPOCH FROM (NOW() - NEW.start_date)) / (365 * 24 * 60 * 60)))::DATE
            ELSE NULL
        END;
    ELSE
        NEW.next_payment_date = NULL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER calculate_subscription_next_payment
    BEFORE INSERT OR UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION calculate_next_payment_date();
```

### 4.3 êµ¬ë… ë³€ê²½ ì´ë ¥ ìë™ ê¸°ë¡
```sql
CREATE OR REPLACE FUNCTION record_subscription_history()
RETURNS TRIGGER AS $$
DECLARE
    change_type TEXT;
    changed_fields JSONB;
BEGIN
    -- ë³€ê²½ ìœ í˜• ê²°ì •
    IF TG_OP = 'INSERT' THEN
        change_type := 'created';
    ELSIF OLD.status != NEW.status THEN
        change_type := CASE NEW.status
            WHEN 'paused' THEN 'paused'
            WHEN 'canceled' THEN 'canceled'
            WHEN 'active' THEN 'resumed'
        END;
    ELSIF OLD.amount != NEW.amount THEN
        change_type := 'price_changed';
    ELSE
        change_type := 'updated';
    END IF;
    
    -- ë³€ê²½ëœ í•„ë“œ ì¶”ì 
    changed_fields := jsonb_build_object();
    IF OLD IS NOT NULL THEN
        -- ê° í•„ë“œë³„ ë³€ê²½ì‚¬í•­ ê¸°ë¡
        IF OLD.amount != NEW.amount THEN
            changed_fields := changed_fields || 
                jsonb_build_object('amount', jsonb_build_object('old', OLD.amount, 'new', NEW.amount));
        END IF;
        -- ... ë‹¤ë¥¸ í•„ë“œë“¤ë„ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
    END IF;
    
    -- ì´ë ¥ ê¸°ë¡
    INSERT INTO subscription_history (
        subscription_id,
        change_type,
        changed_fields,
        snapshot,
        created_by
    ) VALUES (
        NEW.id,
        change_type,
        changed_fields,
        to_jsonb(NEW),
        auth.uid()
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER record_subscription_changes
    AFTER INSERT OR UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION record_subscription_history();
```

---

## 5. ë·° (Views)

### 5.1 ì‚¬ìš©ì êµ¬ë… ìš”ì•½ ë·°
```sql
CREATE VIEW user_subscription_summary AS
SELECT 
    u.id as user_id,
    COUNT(s.id) FILTER (WHERE s.is_active) as active_subscriptions,
    COUNT(s.id) FILTER (WHERE s.status = 'paused') as paused_subscriptions,
    COUNT(s.id) FILTER (WHERE s.status = 'canceled') as canceled_subscriptions,
    
    -- KRW í•©ê³„
    COALESCE(SUM(s.monthly_amount) FILTER (WHERE s.currency = 'KRW' AND s.is_active), 0) as total_krw_monthly,
    
    -- USD í•©ê³„
    COALESCE(SUM(s.monthly_amount) FILTER (WHERE s.currency = 'USD' AND s.is_active), 0) as total_usd_monthly,
    
    -- ì´ ì›í™” í™˜ì‚° (USD * í™˜ìœ¨ + KRW)
    COALESCE(
        SUM(s.monthly_amount) FILTER (WHERE s.currency = 'KRW' AND s.is_active), 0
    ) + COALESCE(
        SUM(s.monthly_amount * er.usd_krw) FILTER (WHERE s.currency = 'USD' AND s.is_active), 0
    ) as total_krw_converted,
    
    -- í‰ê·  êµ¬ë…ë£Œ
    AVG(s.monthly_amount) FILTER (WHERE s.is_active) as avg_subscription_amount,
    
    -- ë‹¤ìŒ ê²°ì œ ì˜ˆì •
    MIN(s.next_payment_date) FILTER (WHERE s.is_active) as next_payment_date
    
FROM auth.users u
LEFT JOIN subscriptions s ON u.id = s.user_id AND s.deleted_at IS NULL
LEFT JOIN exchange_rates er ON u.id = er.user_id
GROUP BY u.id;
```

### 5.2 ì›”ë³„ ê²°ì œ ìº˜ë¦°ë” ë·°
```sql
CREATE VIEW monthly_payment_calendar AS
SELECT 
    s.user_id,
    s.id as subscription_id,
    s.service_name,
    s.service_image_url,
    s.amount,
    s.currency,
    s.payment_day,
    s.next_payment_date,
    
    -- ì´ë²ˆ ë‹¬ ê²°ì œì¼ ê³„ì‚°
    CASE 
        WHEN s.payment_cycle = 'monthly' THEN
            DATE_TRUNC('month', CURRENT_DATE) + (s.payment_day - 1) * INTERVAL '1 day'
        WHEN s.payment_cycle = 'yearly' AND 
             EXTRACT(MONTH FROM s.start_date) = EXTRACT(MONTH FROM CURRENT_DATE) THEN
            DATE_TRUNC('month', CURRENT_DATE) + (s.payment_day - 1) * INTERVAL '1 day'
        ELSE NULL
    END as this_month_payment_date
    
FROM subscriptions s
WHERE s.is_active = true
AND s.payment_day IS NOT NULL;
```

---

## 6. ì¸ë±ìŠ¤ ìµœì í™”

```sql
-- ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ì¶”ê°€ ì¸ë±ìŠ¤
CREATE INDEX idx_subscriptions_user_status ON subscriptions(user_id, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_subscriptions_currency ON subscriptions(currency) WHERE is_active = true;
CREATE INDEX idx_subscriptions_payment_cycle ON subscriptions(payment_cycle) WHERE is_active = true;

-- ë³µí•© ì¸ë±ìŠ¤
CREATE INDEX idx_subscriptions_user_next_payment ON subscriptions(user_id, next_payment_date) 
    WHERE is_active = true;

-- ë¶€ë¶„ ì¸ë±ìŠ¤ (í™œì„± êµ¬ë…ë§Œ)
CREATE INDEX idx_active_subscriptions ON subscriptions(user_id, service_name, amount) 
    WHERE status = 'active' AND deleted_at IS NULL;

-- ì•ŒëŒ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_alarms_schedule ON subscription_alarms(alarm_day, alarm_time, is_active) 
    WHERE is_active = true;

-- ì•Œë¦¼ ì´ë ¥ ì¡°íšŒ ìµœì í™”
CREATE INDEX idx_notifications_recent ON notification_history(user_id, sent_at DESC) 
    WHERE sent_at > NOW() - INTERVAL '30 days';
```

---

## 7. ìƒ˜í”Œ ë°ì´í„°

```sql
-- í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ìƒì„± í›„ ì‹¤í–‰
-- ì¹´í…Œê³ ë¦¬ëŠ” íŠ¸ë¦¬ê±°ë¡œ ìë™ ìƒì„±ë¨

-- ê²°ì œ ìˆ˜ë‹¨ ì¶”ê°€
INSERT INTO payment_methods (user_id, method_type, provider, last_four, nickname, is_default) VALUES
(auth.uid(), 'card', 'ì‹ í•œì¹´ë“œ', '1234', 'ì‹ í•œ ì²´í¬ì¹´ë“œ', true),
(auth.uid(), 'card', 'ì‚¼ì„±ì¹´ë“œ', '5678', 'ì‚¼ì„± ì‹ ìš©ì¹´ë“œ', false);

-- êµ¬ë… ì¶”ê°€
INSERT INTO subscriptions (
    user_id, service_name, service_url, amount, currency, 
    payment_cycle, payment_day, status, start_date
) VALUES
(auth.uid(), 'Netflix', 'https://netflix.com', 17000, 'KRW', 'monthly', 15, 'active', '2024-01-15'),
(auth.uid(), 'Spotify', 'https://spotify.com', 10900, 'KRW', 'monthly', 20, 'active', '2024-03-20'),
(auth.uid(), 'ChatGPT Plus', 'https://chat.openai.com', 20, 'USD', 'monthly', 1, 'active', '2024-06-01');

-- ì•ŒëŒ ì„¤ì •
INSERT INTO subscription_alarms (user_id, subscription_id, alarm_type, alarm_day) 
SELECT 
    user_id,
    id,
    'payment_due',
    unnest(ARRAY[3, 1, 0])
FROM subscriptions
WHERE user_id = auth.uid();
```

---

## 8. ì„±ëŠ¥ ë° ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### ì„±ëŠ¥ ìµœì í™”
- **íŒŒí‹°ì…”ë‹**: ëŒ€ìš©ëŸ‰ í…Œì´ë¸”(notification_history)ì€ ì›”ë³„ íŒŒí‹°ì…”ë‹ ê³ ë ¤
- **ì¸ë±ìŠ¤ ì „ëµ**: ìì£¼ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼ ìœ„ì£¼ë¡œ ì¸ë±ìŠ¤ ìƒì„±
- **ë·° ìºì‹±**: Materialized View ì‚¬ìš© ê²€í† 
- **ì¿¼ë¦¬ ìµœì í™”**: EXPLAIN ANALYZEë¡œ ì¿¼ë¦¬ í”Œëœ í™•ì¸

### ë³´ì•ˆ ê°•í™”
- **RLS í•„ìˆ˜**: ëª¨ë“  í…Œì´ë¸”ì— Row Level Security ì ìš©
- **ì…ë ¥ ê²€ì¦**: CHECK ì œì•½ê³¼ íŠ¸ë¦¬ê±°ë¡œ ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
- **ê°ì‚¬ ì¶”ì **: ëª¨ë“  ë³€ê²½ì‚¬í•­ì„ history í…Œì´ë¸”ì— ê¸°ë¡
- **ì•”í˜¸í™”**: ë¯¼ê°í•œ ì •ë³´ëŠ” pgcrypto í™•ì¥ìœ¼ë¡œ ì•”í˜¸í™”

---

*ì´ ERDëŠ” Moonwave v2.0ì˜ ì™„ì „í•œ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ë¥¼ ë‹´ê³  ìˆìœ¼ë©°, Supabase PostgreSQL í™˜ê²½ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.*
